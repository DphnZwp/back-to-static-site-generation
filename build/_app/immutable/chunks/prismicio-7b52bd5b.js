import{H as T}from"./control-f5b05b5f.js";import{a as F}from"./index-2659d2a2.js";function J(s,e){return new T(s,e)}const L=s=>/^[a-zA-Z0-9][-a-zA-Z0-9]{2,}[a-zA-Z0-9]$/.test(s);class f extends Error{constructor(e="An invalid API response was returned",t,r){super(e),this.url=t,this.response=r}}const B=s=>{if(L(s))return`https://${s}.cdn.prismic.io/api/v2`;throw new f(`An invalid Prismic repository name was given: ${s}`,void 0,void 0)},q=s=>{try{return new URL(s),!0}catch{return!1}},y=s=>Array.isArray(s)?s:[s],D={accessToken:"access_token"},E=s=>typeof s=="string"?s:[s.field,s.direction==="desc"?s.direction:void 0].filter(Boolean).join(" "),I=(s,e)=>{var t;const{predicates:r,...a}=e,i=new URL("documents/search",`${s}/`);if(r)for(const o of y(r))i.searchParams.append("q",`[${o}]`);for(const o in a){const n=(t=D[o])!=null?t:o;let l=a[o];if(n==="orderings"){const d=a[n];d!=null&&(l=`[${y(d).map(A=>E(A)).join(",")}]`)}else n==="routes"&&typeof a[n]=="object"&&(l=JSON.stringify(y(a[n])));l!=null&&i.searchParams.set(n,y(l).join(","))}return i.toString()},h=(s={},e)=>({...s,predicates:[...s.predicates||[],...y(e)]}),_=s=>typeof s=="function"?s:()=>s,m=(s,e)=>{const t=s.find(r=>e(r));if(!t)throw new f("Ref could not be found.",void 0,void 0);return t},v=s=>m(s,e=>e.isMasterRef),R=(s,e)=>m(s,t=>t.id===e),w=(s,e)=>m(s,t=>t.label===e),$="io.prismic.preview",b=s=>s.replace(/%3B/g,";"),C=s=>{const e=s.split("; ");let t;for(const r of e){const a=r.split("=");if(b(a[0]).replace(/%3D/g,"=")===$){t=b(a.slice(1).join("="));continue}}return t},M=s=>s.replace(/(\n| )*( |{|})(\n| )*/gm,(e,t,r)=>r);class U extends f{}class x extends f{}class Q extends f{}const P=s=>Array.isArray(s)?`[${s.map(P).join(", ")}]`:typeof s=="string"?`"${s}"`:s instanceof Date?`${s.getTime()}`:`${s}`,c=s=>(t,...r)=>{const a=r.map(P).join(", "),i=t&&r.length?", ":"";return`[${s}(${t}${i}${a})]`},S=s=>{const e=c(s);return r=>e(r)},z=s=>{const e=c(s);return(...r)=>e("",...r)},u={at:c("at"),not:c("not"),any:c("any"),in:c("in"),fulltext:c("fulltext"),has:S("has"),missing:S("missing"),similar:z("similar"),geopointNear:c("geopoint.near"),numberLessThan:c("number.lt"),numberGreaterThan:c("number.gt"),numberInRange:c("number.inRange"),dateAfter:c("date.after"),dateBefore:c("date.before"),dateBetween:c("date.between"),dateDayOfMonth:c("date.day-of-month"),dateDayOfMonthAfter:c("date.day-of-month-after"),dateDayOfMonthBefore:c("date.day-of-month-before"),dateDayOfWeek:c("date.day-of-week"),dateDayOfWeekAfter:c("date.day-of-week-after"),dateDayOfWeekBefore:c("date.day-of-week-before"),dateMonth:c("date.month"),dateMonthAfter:c("date.month-after"),dateMonthBefore:c("date.month-before"),dateYear:c("date.year"),dateHour:c("date.hour"),dateHourAfter:c("date.hour-after"),dateHourBefore:c("date.hour-before")},G=100,j=5e3,O=500,g=s=>u.at("document.type",s),k=s=>u.at("document.tags",y(s)),p=s=>u.any("document.tags",y(s)),H=(s,e)=>new N(s,e);class N{constructor(e,t={}){if(this.refState={mode:"Master",autoPreviewsEnabled:!0},this.cachedRepositoryExpiration=0,this.graphqlFetch=this.graphQLFetch.bind(this),q(e)?this.endpoint=e:this.endpoint=B(e),this.accessToken=t.accessToken,this.routes=t.routes,this.brokenRoute=t.brokenRoute,this.defaultParams=t.defaultParams,t.ref&&this.queryContentFromRef(t.ref),typeof t.fetch=="function")this.fetchFn=t.fetch;else if(typeof globalThis.fetch=="function")this.fetchFn=globalThis.fetch;else throw new f("A valid fetch implementation was not provided. In environments where fetch is not available (including Node.js), a fetch implementation must be provided via a polyfill or the `fetch` option.",void 0,void 0);this.fetchFn===globalThis.fetch&&(this.fetchFn=this.fetchFn.bind(globalThis)),this.graphQLFetch=this.graphQLFetch.bind(this)}enableAutoPreviews(){this.refState.autoPreviewsEnabled=!0}enableAutoPreviewsFromReq(e){this.refState.httpRequest=e,this.refState.autoPreviewsEnabled=!0}disableAutoPreviews(){this.refState.autoPreviewsEnabled=!1}async query(e,t){const r=await this.buildQueryURL({...t,predicates:e});return await this.fetch(r,t)}async get(e){const t=await this.buildQueryURL(e);return await this.fetch(t,e)}async getFirst(e){var t,r;const a={...e};!(e&&e.page)&&!(e!=null&&e.pageSize)&&(a.pageSize=(r=(t=this.defaultParams)==null?void 0:t.pageSize)!=null?r:1);const i=await this.buildQueryURL(a),n=(await this.fetch(i,e)).results[0];if(n)return n;throw new f("No documents were returned",i,void 0)}async dangerouslyGetAll(e={}){var t;const{limit:r=1/0,...a}=e,i={...a,pageSize:Math.min(r,a.pageSize||((t=this.defaultParams)==null?void 0:t.pageSize)||G)},o=[];let n;for(;(!n||n.next_page)&&o.length<r;){const l=n?n.page+1:void 0;n=await this.get({...i,page:l}),o.push(...n.results),n.next_page&&await new Promise(d=>setTimeout(d,O))}return o.slice(0,r)}async getByID(e,t){return await this.getFirst(h(t,u.at("document.id",e)))}async getByIDs(e,t){return await this.get(h(t,u.in("document.id",e)))}async getAllByIDs(e,t){return await this.dangerouslyGetAll(h(t,u.in("document.id",e)))}async getByUID(e,t,r){return await this.getFirst(h(r,[g(e),u.at(`my.${e}.uid`,t)]))}async getByUIDs(e,t,r){return await this.get(h(r,[g(e),u.in(`my.${e}.uid`,t)]))}async getAllByUIDs(e,t,r){return await this.dangerouslyGetAll(h(r,[g(e),u.in(`my.${e}.uid`,t)]))}async getSingle(e,t){return await this.getFirst(h(t,g(e)))}async getByType(e,t){return await this.get(h(t,g(e)))}async getAllByType(e,t){return await this.dangerouslyGetAll(h(t,g(e)))}async getByTag(e,t){return await this.get(h(t,p(e)))}async getAllByTag(e,t){return await this.dangerouslyGetAll(h(t,p(e)))}async getByEveryTag(e,t){return await this.get(h(t,k(e)))}async getAllByEveryTag(e,t){return await this.dangerouslyGetAll(h(t,k(e)))}async getBySomeTags(e,t){return await this.get(h(t,p(e)))}async getAllBySomeTags(e,t){return await this.dangerouslyGetAll(h(t,p(e)))}async getRepository(e){const t=new URL(this.endpoint);return this.accessToken&&t.searchParams.set("access_token",this.accessToken),await this.fetch(t.toString(),e)}async getRefs(e){return(await this.getRepository(e)).refs}async getRefByID(e,t){const r=await this.getRefs(t);return R(r,e)}async getRefByLabel(e,t){const r=await this.getRefs(t);return w(r,e)}async getMasterRef(e){const t=await this.getRefs(e);return v(t)}async getReleases(e){return(await this.getRefs(e)).filter(r=>!r.isMasterRef)}async getReleaseByID(e,t){const r=await this.getReleases(t);return R(r,e)}async getReleaseByLabel(e,t){const r=await this.getReleases(t);return w(r,e)}async getTags(e){try{const t=await this.getCachedRepositoryForm("tags",e),r=new URL(t.action);return this.accessToken&&r.searchParams.set("access_token",this.accessToken),await this.fetch(r.toString(),e)}catch{return(await this.getRepository(e)).tags}}async buildQueryURL({signal:e,...t}={}){const r=t.ref||await this.getResolvedRefString(),a=t.integrationFieldsRef||(await this.getCachedRepository({signal:e})).integrationFieldsRef||void 0;return I(this.endpoint,{...this.defaultParams,...t,ref:r,integrationFieldsRef:a,routes:t.routes||this.routes,brokenRoute:t.brokenRoute||this.brokenRoute,accessToken:t.accessToken||this.accessToken})}async resolvePreviewURL(e){var t,r;let a=e.documentID,i=e.previewToken;if(typeof globalThis.location<"u"){const o=new URLSearchParams(globalThis.location.search);a=a||o.get("documentId"),i=i||o.get("token")}else if(this.refState.httpRequest){if("query"in this.refState.httpRequest)a=a||((t=this.refState.httpRequest.query)==null?void 0:t.documentId),i=i||((r=this.refState.httpRequest.query)==null?void 0:r.token);else if("url"in this.refState.httpRequest&&this.refState.httpRequest.url){const o=new URL(this.refState.httpRequest.url).searchParams;a=a||o.get("documentId"),i=i||o.get("token")}}if(a!=null&&i!=null){const o=await this.getByID(a,{signal:e.signal,ref:i,lang:"*"}),n=F(o,e.linkResolver);if(typeof n=="string")return n}return e.defaultURL}queryLatestContent(){this.refState.mode="Master"}queryContentFromReleaseByID(e){this.refState={...this.refState,mode:"ReleaseID",releaseID:e}}queryContentFromReleaseByLabel(e){this.refState={...this.refState,mode:"ReleaseLabel",releaseLabel:e}}queryContentFromRef(e){this.refState={...this.refState,mode:"Manual",ref:e}}async graphQLFetch(e,t){const r=await this.getCachedRepository(),a=await this.getResolvedRefString(),i={"Prismic-ref":a,Authorization:this.accessToken?`Token ${this.accessToken}`:"",...t?t.headers:{}};r.integrationFieldsRef&&(i["Prismic-integration-field-ref"]=r.integrationFieldsRef);const o={};for(const d in i)i[d]&&(o[d.toLowerCase()]=i[d]);const n=new URL(e);n.searchParams.set("ref",a);const l=n.searchParams.get("query");return l&&n.searchParams.set("query",M(l)),await this.fetchFn(n.toString(),{...t,headers:o})}async getCachedRepository(e){return(!this.cachedRepository||Date.now()>=this.cachedRepositoryExpiration)&&(this.cachedRepositoryExpiration=Date.now()+j,this.cachedRepository=await this.getRepository(e)),this.cachedRepository}async getCachedRepositoryForm(e,t){const a=(await this.getCachedRepository(t)).forms[e];if(!a)throw new f(`Form with name "${e}" could not be found`,void 0,void 0);return a}async getResolvedRefString(e){var t,r;if(this.refState.autoPreviewsEnabled){let o,n;if((t=this.refState.httpRequest)!=null&&t.headers?"get"in this.refState.httpRequest.headers&&typeof this.refState.httpRequest.headers.get=="function"?n=this.refState.httpRequest.headers.get("cookie"):"cookie"in this.refState.httpRequest.headers&&(n=this.refState.httpRequest.headers.cookie):(r=globalThis.document)!=null&&r.cookie&&(n=globalThis.document.cookie),n&&(o=C(n)),o)return o}const a=await this.getCachedRepository(e),i=this.refState.mode;if(i==="ReleaseID")return R(a.refs,this.refState.releaseID).ref;if(i==="ReleaseLabel")return w(a.refs,this.refState.releaseLabel).ref;if(i==="Manual"){const o=await _(this.refState.ref)();if(typeof o=="string")return o}return v(a.refs).ref}async fetch(e,t={}){const r=await this.fetchFn(e,{signal:t.signal});let a;try{a=await r.json()}catch{throw r.status===404?new x(`Prismic repository not found. Check that "${this.endpoint}" is pointing to the correct repository.`,e,void 0):new f(void 0,e,void 0)}switch(r.status){case 200:return a;case 400:throw new Q(a.message,e,a);case 401:case 403:throw new U("error"in a?a.error:a.message,e,a)}throw new f(void 0,e,a)}}const Y="lose-your-head-the-client-case",X=({request:s,fetch:e})=>{const r=H(Y,{fetch:e});return s&&r.enableAutoPreviewsFromReq(s),r};export{X as c,J as e};
